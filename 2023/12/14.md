## 取り組んだ課題   
   REST API 動画視聴   
   REST APIについてまとめる   
## わかったこと   
### エラー表現で考慮すること   
エラー詳細はレスポンスボディーに入れいる   
→レスポンスのステータスコードのみだとわからないため、足りない情報を追加情報としてボディに含める   
   
エラー時にHTMLを返さないようにする   
→レスポンスフォーマットが変わるとクライアントアプリ側で処理できないケースがある   
   
サービス閉塞時は503 + "Retry-After"   
→いつ再開するのかがわかるため   
   
   
### API バージョンの表現   
   
* APIにバージョンを含めるか   
  メリット: 特定バージョン指定でアクセスできるため、   
  クライアント側で突然エラーにはならない→クライアント側のメリット   
  デメリット: 複数バージョンが並列稼働になるため、ソースコードやデータベースの管理が複雑になる→開発側のデメリット   
  広く世間一般に効果するようなサービスを展開するよ雨であれば、利用者の利便性を考慮してAPIバージョンを含めたURL設計を行う   
* バージョンを入れる場所   
　3箇所存在する   
　* パスに入れる 実務上は一番多い方法   
    `http://api.example.com/v1/users/`   
    →RESTの設計に基づいて設計する場合、   
    実務上一番多いとされるこの実装も不適切   
　* クエリに入れる   
    `http://api.example.com/users?version=1`   
　* ヘッダーに入れる   
    HTTPのヘッダーに独自定義する場合かつては"X-接頭辞(prefix)が推奨されていたが2012/6以降は非推奨   
    非推奨になってからは、サービス固有の接頭辞をつける   
    (例: GData-Version)   
    `GET http:api.example.com/users`   
    X-api-Version: 1   
    REST APIの設計としてはヘッダーに入れるのがおすすめ   
    →実務ではパスに入れることが多い   
* バージョンの付け方   
  * セマンティックバージョン   
 　　バージョン: 1.2.3   
    →メジャー.マイナー.パッチの順に並ぶ   
    * メジャーバージョン   
      後方互換しない修正   
    * マイナーバージョン   
      後方互換する機能追加   
    * パッチ   
      後方互換するバグ修正   
  上記を踏まえAPIのバージョンの付け方は後方互換しなくなったタイミング(メジャーバージョンを上げる)でつける   
  →マイナーやパッチでつけるとその分管理が増えるため   
  　最低限守るのは後方互換しないメジャーバージョンのみ   
   
### OAuthとOpenID Connect   
* 認証と認可   
  * 認証(Authentication)   
    本人を特定する   
    アクセスしてきた人が誰であるかを調べる   
    * 認証の三要素   
      * What you are(inherence factor)   
        顔貌、声、指紋、署名などその人自身を提示して、相手にアイデンティティを確認させる法方   
      * what you hava(possesion factor)   
        身分証、携帯電話等、その人だけが持っているものを提示して認証   
　　　 * What you know(knowledge factor)   
  　　　 パスワード、秘密の質問等、その人だけが知っていることを提示して認証   
   
  * 認可(Authorization)   
    アクセス制御   
    認証ができた人が、ある特定のリソースにアクセスできるかどうかを制御する   
    純粋な認可はそれがあるからと言って身元が明らかになるという話ではない   
    →駅で切符をかったからといってその人の身元が明らかになるわけではない   
    認可はそれを持っていることによって(リソースアクセスが許される)   
  * 認証と認可の分離の疑問   
    * 認証せずに認可することはあるのか？   
      例)特定のIPアドレスからリクエストを許可する   
      上記は認証に基づかない認可の例   
    * 認証したのに認可がないことはあるのか   
      1つのシステムに閉じている場合はまずないと考えるのが普通   
      しかし、認証の委譲が発生するような分散環境では変わる   
      Aシステムがユーザの認証を行い、その事実をBシステムに通知したという状態において、Aシステムは認証はしたが、認可はしていないことになる   
    * 一方ミクロな視点で、BシステムはAシステムからユーザを認証したことを通知された。だから、Bシステムは独自で持つリソースへのアクセスを許すことにした。ということはある。   
    →比喩的な例でいうと、マイナンバーカードを利用して、レンタルビデオ店の会員権を得る話   
    マイナンバー自体は何も認可していない。レンタルビデオ店がマイナンバーカードに基づいて認可しているが、マイナンバー側からしたらしらんということになる   
   
   
   
* OAuthとOpenID Connectの違い   
  どちらも認可についてのサービス   
  OpenID ConnectはOAuthに本人情報取得を加えた仕組み   
    OAuth: 認可   
    OpenID Connect: 認可 + 本人情報取得   
* OAuth概要   
  Authorization Code フロー   
  リソースオーナー(利用者)、サードパーティアプリ、サービスが登場人物   
  1. 利用者はサードパーティアプリにサービス連携を試みる   
  2. サードパーティアプリはサービスに対して問い合わせし、　　サービスはそれをリダイレクトして利用者にログイン画面をリダイレクトする   
  3. ユーザがログイン情報をサービスに返す   
  4. 認証が取れたら認可コードをサードパーティアプリに渡す。　   
  5. サービス側からアクセストークンをもらう   
     →アクセストークンは認可情報を持っている   
  6. サービス情報に対してアクセストークンを利用してAPIを利用できる   
   
* OpenID Connect 概要   
  OAuthと基本的な流れは同じ   
  code フローの場合   
  OAuthと1~4は同じ   
  そこから、OpenID Connectの場合は、   
  アクセストークンに加えて、IDトークンも返す   
  IDトークンは認証結果情報   
  JSON Web Token(JWT)で返される   
　その後、アクセストークンをサービスに返し、個人情報を取得する   
   
* JWT(JSON Web Token)   
  ジョットと読む   
  仕様: RFC-7519 - JSON Web Token(JWT)で標準化   
  特徴   
    署名による改ざんチェック   
    URL-safe なデータ   
    データの中身をJSON形式で返す   
  認証結果をサーバーサイドで保存せず、クライアントサイドで保持(ステートレスな通信の実現)   
  * 構成   
    ヘッダ、ペイロード、署名で構成され、それぞれ、base64UrlEncodeでデコードされた状態で格納される   
    また、ペイロードがピリオドで囲まれた状態で   
    一行で格納される   
    `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`   
   
    ```json   
    {   
      "typ": "JWT",   
      "alg": "ES256"    
    }   
    ```    
    * header   
      * typ   
        名称:type   
        概要:"JWT"で固定   
      * alg   
        名称:algorithm   
        概要: 署名に利用できるアルゴリズム   
              HS256: HMAC using SHA-256   
              RS256: RSASSA-PKCS1-v1_5 using SHA-256   
              ES256: ECDSA using P-256 and SHA-256   
              none: 暗号なし   
                    →偽装可能のため利用しない   
    * payload   
      保存したいデータの実態   
      入れたいものを入れる   
      予約済みクレームとプライベートクレームに分類される   
      ```json   
      {   
        "sub": "1234567890",   
        "name": "John Doe",   
        "iat": "1516239022"    
      }   
      ```   
      * 予約済みクレーム   
        * iss   
          名称:Issuer   
          概要:JWTを発行しているサービス、システムの識別子   
        * sub   
          名称: Subject   
          概要: 同一Issue内での識別子   
              　該当サービスにおける、ユーザIDなど   
        * aud   
          名称: Audience   
          概要: JWTを利用してるサービス、システムの識別子   
        * exp   
          名称:expiration time   
          概要:有効期限   
        * jti   
          名称:JWT ID   
          概要: JWTの再利用を防ぐために一意に発行されたID   
   
      * signature   
        改ざんされていないか確認するためのもの   
        ヘッダーで指定されたアルゴリズムで、ヘッダーとペイロードをつなげたものをSECRETで暗号化されたもの   
　　　　　   
        [jwt.io](https://jwt.io/)で確認できる   
   
    * Authorizationヘッダー   
      認証で利用するヘッダーにAuthorizationヘッダーがある   
      JWTを利用する際は、このAuthorizationヘッダーに埋め込んで利用する   
      Authorization: <type> <credentials>   
      * type   
        * Basic: ベーシック認証(ID,passwordを平文で送信)   
        * Bearer: OAuth2.0(JWTを使う場合はこれ)   
        * Digest: ダイジェスト認証(IDとパスワードをハッシュ化して送信)   
        * OAuth: OAuth1.0   
      * credentials   
        認証情報を記述   
        記述内容は認証方法によって異なる   
        JWTの場合、JWTの実態がcredentialに記載される   
        上記を踏まえ,JWTを送信する場合は以下   
        Authorization: Bearer <JWT credential>   
   
  * 大量アクセス対策   
    レートリミット   
    →時間あたりのアクセス制限を指す   
   
    WebアプリをAPI化することで発生する問題は？   
    問題点: API化により、簡単に大量アクセスするプログラムが書ける。意図しない、プログラマの不注意で大量アクセスが発生する   
    対応策: 時間あたりのアクセス制限をかける   
       
    * レートリミットで考慮すること   
      誰に対して: APIキー、ユーザID   
      何に対して: 単一機能、機能群、API全体   
      制限回数: 10回, 100回, 1000回   
      単位時間(制限をリセットするタイミング): 10分、 1時間, 1日など   
   
      制限をリセットするタイミングはWindowとも呼ばれる   
   
   
    * レートリミットアルゴリズム   
  　　　代表的なレートリミットのアルゴリズム   
      * Fixed Window   
        sample   
        30回/10分のレートリミットの場合   
        固定で時間枠が決まり、その時間になるとカウントがリセットされる   
        →切り替え間際に大量のリクエストが来ると、その周辺の時間のみでリクエスト数を切り取ると制限をかけた30回以上のリクエストが来ていることなる   
      * Sliding Log   
        30回/10分の場合   
        最新のリクエスト履歴絡みて、過去10分間のリクエストが30件以内かどうかで判断する   
        →過去ログを大量に保存する必要がある   
        ログの破棄も考える必要がある   
      * Sliding Window   
        30回/10分の場合   
        fixed windowとsliding logを組み合わたもの   
        最新のリクエストから過去10分の間のリクエスト数の比率で計算する   
        xはレートリミットで区切った値から何分経過してるか   
        preCount * (1 - x分/ 10分) + curCount　< 30   
           
　　　* アクセス制限の緩和   
  　　　接続元によっては特別な緩和措置が必要なケースがある   
  　　　例えば、サービス利用が多く、自社にとって優良顧客である場合   
  　　　キャンペーンなど、一時的に負荷増大がある場合   
      　→アクセス元ごとにアクセス制限を緩和する必要がある   
   
### キャッシュ制御   
  キャッシュ制御に利用するヘッダーは2分類3パターン   
  * 有効期限による制御   
    * Expires   
      キャッシュとしていつまで利用可能かの期限を指定   
      Cache-Controlが設定されている場合は無視されるので注意   
    * Cache-Control + Date   
      * キャッシュ可否   
        public: 追伸経路上のどこでも保存できる   
        private: クライアント端末のみ保存できる   
        no-cache: 保存できるがかならず有効性の確認が必要→かならず利用できるかをサーバーに問い合わせする　   
        no-store: 保存不可   
      * キャッシュ期限   
        max-age=<秒>: 新しいとみなせる時間(秒)   
   
  * 検証による制御   
    * Last-Modified + ETag   
      Last-Modifiedにリソースの最終更新日を指定   
      Etagに特定のバージョンを示す文字列が保存されている   
      コンテンツのハッシュ   
      バージョン番号   
      最終更新日時のハッシュなど   
  * キャッシュさせる単位   
    Varyに制御単位を記述することで制御できる   
   
   
### セキュリティ   
   
* APIはどこから呼ばれるのか   
  * 呼び出し元   
    * スマホアプリ   
    * Webページ   
      * Scriptタグ   
      * JavaScript   
    * 外部システム(バッチ)   
* 脆弱性   
  * XSS(クロスサイトスクリプティング)   
    対策: レスポンスヘッダーの追加   
    X-XSS-Protection: "1"でXSSをフィルタリング有効化   
    X-Frame-Options: "DENY"でframeタグ呼び出しを拒否   
    X-content-Type-Optoins: "nosniff" IE脆弱性対応   
  * CSRF(クロスサイトリクエストフォージェリー)    
    対策   
      * 許可しないアクセス元からのリクエストを拒否   
        * X-API-Key   
          システム単位で実行可否判断   
        * Authentication: ユーザ単位で実行可能可否判断   
      * 攻撃者に推測されにくいトークンの発行・照合処理を実装   
        * X-CSRF-TOKEN   
          トークンを使って実行可否判断   
           
      X-API-Key,X-CSRF-TOKENはそれぞれGoogle,SpringSecurityで独自に作成されたヘッダー   
  * HTTP   
    暗号化されていない通信   
    対策   
      HTTPS化する   
  * JWT   
    クライアント側で、内容確認改ざんが簡単にできる   
    サーバー側の検証が不十分だと改ざんされた情報を正規として受け入れてしまう   
    対策   
    * ヘッダーのalgに"none"以外を指定して署名を暗号化する   
    ```json   
      {   
        "typ": "JWT",   
        "alg": "ES256"   
      }   
    ```   
   
    * ペイロードのaudに想定する利用者を指定して受信時に検証する   
    ```json   
      {   
        "sub": "1234567890",   
        "name": "John Dow",   
        "aud": "https//api.example.com/"   
      }   
    ```   
## 次にやること   
REST APIについてまとめる
Ruby on Rails動画視聴
## 感じたこと   
動画視聴、まとめに時間がかかってしまい、Railsまでいけなかったので明日はRailsに着手する
## 学習時間   
 today:5.0h   
 total:248.0h   