## 取り組んだ課題   
 達人に学ぶDB設計　徹底指南書    
## わかったこと   
* 親ソート性   
  以下の処理を記述した際に、DBMSでは内部でソートが行われる   
  * 集約関数(max,min,avg,count,sum)   
  * order by   
  * 集合演算   
  * OLAP関数(rank, row_number)   
  ソートとは通常コストが高い処理   
  ソートがDBMSで行われる際に、専用のメモリ領域が割り当てられており、その中で、一時的にデータを保持してソートされるが、大量のデータのソートが必要な場合に、メモリのみでは処理しきれない場合にディスクへI/Oが発生するため、   
  非常に時間のかかる処理となる   
   
  インデックスが存在する列をorder byする時、   
  ソート処理をスキップすることができ、処理が早くなる   
   
* B-treeインデックスの設計方針   
  * 大規模なテーブル   
  * カーディナリティ(多重度)の高い列   
  * SQLでWHERE句の選択条件、または結合条件に使用されている列   
   
   
  データ量が少ない場合は、フルスキャンの方が処理が高速な領域が存在する   
  →サーバー、ストレージの性能などの環境にも左右されるが、最近のハードウェアでいうと１万行以下の場合はほぼ効果がない   
   
  カーディナリティとインデックスの関係   
  例　性別   
  1. 男性   
  2. 女性   
  3. 不詳   
  この場合カーディナリティは3となる   
  これは非常に小さいカーディナリティとなる   
   
  逆に多いものは、口座番号や日付は高い   
  日付の場合は、営業日だけに絞った場合でも200日はある   
  B-treeインデックスを作る時は、カーディナリティの高い列を   
  選ぶことが基本   
  この場合の目安は、特定の値を指定した際に、全体レコード数の5％に絞り込めるだけのカーディナリティがあること   
   
* 注意点   
  複合列でインデックスを作成する際は、カーディナリティは複合列の組み合わせで考える   
  たとえば(a,b,c)でそれぞれカーディナリティが2,10,5だとすると組み合わせで考えた際に、カーディナリティは100となる   
  その場合、1つの行は全体の1％となるためインデックスを作成する意味がある(なるべく先頭に近いキー	のカーディナリティが高いと効果を発揮しやすい)   
   
  カーディナリティが高くても、実際に格納されている値が   
  特定の値に集中している場合、結果として、その集中している値の中から検索をする羽目になるため、検索性能はあまり高まらない   
  →データが平均的に分散していることがベスト   
   
### インデックスとSQL   
  SQLで検索条件や、結合条件として使用されない列に   
  インデックスを作成しても効果はない   
   
  インデックスをうまく利用する上で注意すべきSQLの書き方   
  →その書き方をすると効果が発揮されない   
  1. インデックス列に演算を行っている   
 インデックスを作成した列は裸で用いることが原則   
 →インデックスとして持っている値は加工した良い場合、インデックスではなくなる   
 以下の場合、インデックスはあくまでcol_1に対して作成されたものであり、col_1,substr(col_1,1,1)に対して作成されたものではないためNG   
 ```sql   
 -- NG   
 select *   
 from some_table   
 where col_1 * 1.1 > 100   
 ```   
 ```sql   
 --NG 2   
 select *   
 from some_table   
 where substr(col_1, 1, 1) = 'a'   
 ```   
 ```sql   
 --OK   
 select *   
 from some_table   
 where col_1 > 100/1.1   
 ```   
       
## 次にやること   
 達人に学ぶDB設計　徹底指南書    
## 感じたこと   
   
## 学習時間   
 today:2.0h   
 total:228h   