## 取り組んだ課題   
達人に学ぶDB設計　徹底指南書   
## わかったこと   
### インデックスとSQL   
SQLで検索条件や、結合条件として使用されない列に   
インデックスを作成しても効果はない   
   
インデックスをうまく利用する上で注意すべきSQLの書き方   
→その書き方をすると効果が発揮されない   
1. インデックス列に対して演算処理、関数適用を行っている   
   インデックスを作成した列は裸で用いることが原則   
   →インデックスとして持っている値は加工した良い場合、インデックスではなくなる   
   以下の場合、インデックスはあくまでcol_1に対して作成されたものであり、col_1,substr(col_1,1,1)に対して作成されたものではないためNG   
   ```sql   
   -- NG   
   select *   
   from some_table   
   where col_1 * 1.1 > 100   
   ```   
   ```sql   
   --NG 2   
   select *   
   from some_table   
   where substr(col_1, 1, 1) = 'a'   
   ```   
   ```sql   
   --OK   
   select *   
   from some_table   
   where col_1 > 100/1.1   
   ```   
   
2. IS NULLを利用している   
  B-treeインデックスは一般的にNULLについてはデータの値とはみなさず保持しない。   
  したがって、IS NULL、NOT NULLは有効ではない   
  一部のDBMSではIS NULLが有効に作用するが、汎用的ではない     
3. 否定系を用いている   
否定系にはインデックスは利用できない   
理由としては利用しても検索範囲が広いため   
```sql   
select * from some_table   
where col_1 <> 100   
```   
4. ORを利用している   
  ```sql   
  select * from some_table   
  where col_1 = 90 or col_1 = 100;   
  ```   
  orを用いたインデックスは効果がないので、INに書き換えることで回避   
  ```sql   
  where col_1 in(90, 100)   
  ```   
   
5. 後方一致、または中間一致のLIKE述語を用いている   
  ```sql   
  select * from some_table where col_1 like '%a'   
  select * from some_table where col_1 like '%a%'   
  ```   
  like演算子を用いる時は前方一致のみ有効   
6. 暗黙の型変換を行っている   
   前提: 文字列型の列 col_1 に対して条件を書く   
   ```sql   
   --NG   
   select * from some_table where col_1 = 10   
   --OK   
   select * from some_table where col_1 = '10'   
   --OK   
   select * from some_table where col_1 cast(10, as char(2))   
   ```   
   データ型の異なる列値をSQLにおいて選択条件また、結合条件として利用する場合、型変換を行い型を統一する必要がある。   
   データ型の異なる値を条件にした場合、DBMSは内部で暗黙的に型変換を行う。   
   その場合はインデックスが使用されなくなる   
   
   
### 注意点   
* 主キーおよび一意制約の列には作成不要   
* B-treeに限らず、インデックス全般の欠点   
  インデックスはテーブルとは独立のオブジェクトとして内部に保持されるため、インデックスが作成されている対象の列1が更新されると   
  インデックスないに保持している値も変更しなければならない   
  B-treeインデックスを作成すればするほど、当該テーブルに対する更新性能が劣化していく。   
  そのため、無駄なインデックスの作成は避ける   
   
* 定期的なメンテナンスを行う   
  テーブルのデータが更新されていくと長期的には構造が崩れて性能が劣化する。   
  そのため、インデックスの再構築を行うことが望ましい   
  どの程度の頻度で行うべきかは、どの程度の更新量を持つか、などのシステム環境に左右されるため、一概には言えない   
  DBMSごとに、インデックスの構造が崩れている場合の指数値(断片化率や木の高さなど)と、その調査方法が存在する   
  →公式マニュアルにあるとのこと   
   
### インデックスとSQL   
SQLで検索条件や、結合条件として使用されない列に   
インデックスを作成しても効果はない   
   
インデックスをうまく利用する上で注意すべきSQLの書き方   
→その書き方をすると効果が発揮されない   
1. インデックス列に対して演算処理、関数適用を行っている   
   インデックスを作成した列は裸で用いることが原則   
   →インデックスとして持っている値は加工した良い場合、インデックスではなくなる   
   以下の場合、インデックスはあくまでcol_1に対して作成されたものであり、col_1,substr(col_1,1,1)に対して作成されたものではないためNG   
   ```sql   
   -- NG   
   select *   
   from some_table   
   where col_1 * 1.1 > 100   
   ```   
   ```sql   
   --NG 2   
   select *   
   from some_table   
   where substr(col_1, 1, 1) = 'a'   
   ```   
   ```sql   
   --OK   
   select *   
   from some_table   
   where col_1 > 100/1.1   
   ```   
   
2. IS NULLを利用している   
  B-treeインデックスは一般的にNULLについてはデータの値とはみなさず保持しない。   
  したがって、IS NULL、NOT NULLは有効ではない   
  一部のDBMSではIS NULLが有効に作用するが、汎用的ではない     
3. 否定系を用いている   
否定系にはインデックスは利用できない   
理由としては利用しても検索範囲が広いため   
```sql   
select * from some_table   
where col_1 <> 100   
```   
4. ORを利用している   
  ```sql   
  select * from some_table   
  where col_1 = 90 or col_1 = 100;   
  ```   
  orを用いたインデックスは効果がないので、INに書き換えることで回避   
  ```sql   
  where col_1 in(90, 100)   
  ```   
   
5. 後方一致、または中間一致のLIKE述語を用いている   
  ```sql   
  select * from some_table where col_1 like '%a'   
  select * from some_table where col_1 like '%a%'   
  ```   
  like演算子を用いる時は前方一致のみ有効   
6. 暗黙の型変換を行っている   
   前提: 文字列型の列 col_1 に対して条件を書く   
   ```sql   
   --NG   
   select * from some_table where col_1 = 10   
   --OK   
   select * from some_table where col_1 = '10'   
   --OK   
   select * from some_table where col_1 cast(10, as char(2))   
   ```   
   データ型の異なる列値をSQLにおいて選択条件また、結合条件として利用する場合、型変換を行い型を統一する必要がある。   
   データ型の異なる値を条件にした場合、DBMSは内部で暗黙的に型変換を行う。   
   その場合はインデックスが使用されなくなる   
   
   
## 注意点   
* 主キーおよび一意制約の列には作成不要   
* B-treeに限らず、インデックス全般の欠点   
  インデックスはテーブルとは独立のオブジェクトとして内部に保持されるため、インデックスが作成されている対象の列1が更新されると   
  インデックスないに保持している値も変更しなければならない   
  B-treeインデックスを作成すればするほど、当該テーブルに対する更新性能が劣化していく。   
  そのため、無駄なインデックスの作成は避ける   
   
* 定期的なメンテナンスを行う   
  テーブルのデータが更新されていくと長期的には構造が崩れて性能が劣化する。   
  そのため、インデックスの再構築を行うことが望ましい   
  どの程度の頻度で行うべきかは、どの程度の更新量を持つか、などのシステム環境に左右されるため、一概には言えない   
  DBMSごとに、インデックスの構造が崩れている場合の指数値(断片化率や木の高さなど)と、その調査方法が存在する   
  →公式マニュアルにあるとのこと   
   
   
     
## 次にやること   
達人に学ぶDB設計　徹底指南書   
## 感じたこと   
インデックスを作成しても検索方法を意識しないとうまく機能しない点など、   
とりあえずインデックスを作成しておけば良いというわけではないことを理解して今後のSQL利用に役立てたい。   
## 学習時間   
 today:3.5h      
 total:231.5h      